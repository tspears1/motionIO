{"version":3,"sources":["webpack://motion-io/./src/motion-io/transitions.js","webpack://motion-io/./src/motion-io/motion-io.js","webpack://motion-io/./src/motion-io/motion-text-io.js","webpack://motion-io/./src/motion-io/v-motion-io.js","webpack://motion-io/./src/motion-io/v-motion-text-io.js","webpack://motion-io/./example/main.js","webpack://motion-io/./src/motion-io/utilities/reduced-motion.js"],"names":["fadeIn","opacity","slideInDown","translateY","slideInLeft","translateX","slideInRight","slideInUp","revealInDown","clipPath","revealInLeft","revealInRight","revealInUp","textRevealInDown","textRevealInLeft","textRevealInRight","textRevealInUp","zoomIn","scaleX","scaleY","zoomOut","flipX","rotateX","flipY","rotateY","rotateLeft","rotate","rotateRight","standRight","skewZ","el","options","this","selector","onBegin","onChange","onComplete","onEnter","onLeave","once","threshold","rootMargin","root","hasEntered","anime","custom","delay","duration","easing","children","preset","stagger","targets","Object","assign","init","initAnime","initObserver","observer","disconnect","observerOptions","isIntersecting","pause","reverse","play","unobserve","entries","target","IntersectionObserver","observe","transitionStyle","transitions","staggerOptions","Array","isArray","settings","autoplay","loop","begin","complete","className","elementTag","mask","style","text","innerText","textGroup","wordWrap","buildText","renderText","split","map","word","wordArray","buildWrapper","wrapper","document","createElement","classList","add","appendChild","buildWords","phrase","forEach","index","wordEl","display","marginLeft","webkitClipPath","buildLetters","letter","letterEl","isNotIntersecting","querySelectorAll","name","props","type","Boolean","required","default","observerRoot","Function","Number","String","origin","svg","data","computed","$el","targetSelector","reduceMotion","localStorage","getItem","mounted","beforeDestroy","$options","render","$scopedSlots","entered","methods","$emit","$nextTick","activateObserver","length","warn","transformOrigin","strokeDashoffset","message","Vue","console","error","applyStyles","block","tag","html","h","class","node","renderBlock","ref","refInFor","buildStyles","staticClass","childBlock","styles","setTimeout","$refs","delimiters","components","Motion","MotionText","MotionTextIO","MotionIO","motionQuery","matchMedia","updateLocalStorage","value","setItem","reducedMotionCheck","matches","video","getAttribute","addEventListener"],"mappings":"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","file":"/js/main.js","sourcesContent":["const transitions = {\n\n   fadeIn: {\n      opacity: [0, 1]\n   },\n\n   slideInDown: {\n      opacity: [0, 1],\n      translateY: [ '20vh', 0 ]\n   },\n   slideInLeft: {\n      opacity: [0, 1],\n      translateX: [ '-20vw', 0 ]\n   },\n   slideInRight: {\n      opacity: [0, 1],\n      translateX: [ '20vw', 0 ]\n   },\n   slideInUp: {\n      opacity: [0, 1],\n      translateY: [ '-20vh', 0 ]\n   },\n\n   revealInDown: {\n      \"-webkit-clip-path\": [ 'inset(0% 0% 100% 0%)', 'inset(0% 0% 0% 0%)'],\n      clipPath: [ 'inset(0% 0% 100% 0%)', 'inset(0% 0% 0% 0%)']\n   },\n\n   revealInLeft: {\n      \"-webkit-clip-path\": [ 'inset(0% 0% 0% 100%)', 'inset(0% 0% 0% 0%)'],\n      clipPath: [ 'inset(0% 0% 0% 100%)', 'inset(0% 0% 0% 0%)']\n   },\n\n   revealInRight: {\n      \"-webkit-clip-path\": [ 'inset(0% 100% 0% 0%)', 'inset(0% 0% 0% 0%)'],\n      clipPath: [ 'inset(0% 100% 0% 0%)', 'inset(0% 0% 0% 0%)']\n   },\n\n   revealInUp: {\n      \"-webkit-clip-path\": [ 'inset(100% 0% 0% 0%)', 'inset(0% 0% 0% 0%)'],\n      clipPath: [ 'inset(100% 0% 0% 0%)', 'inset(0% 0% 0% 0%)']\n   },\n\n   textRevealInDown: {\n      \"-webkit-clip-path\": [ 'inset(-10% -10% 110% -10%)', 'inset( -10% -10% -10% -10%'],\n      clipPath: [ 'inset(-10% -10% 110% -10%)', 'inset( -10% -10% -10% -10%']\n   },\n\n   textRevealInLeft: {\n      \"-webkit-clip-path\": [ 'inset(-10% -10% -10% 110%)', 'inset( -10% -10% -10% -10%'],\n      clipPath: [ 'inset(-10% -10% -10% 110%)', 'inset( -10% -10% -10% -10%']\n   },\n\n   textRevealInRight: {\n      \"-webkit-clip-path\": [ 'inset(-10% 110% -10% -10%)', 'inset( -10% -10% -10% -10%'],\n      clipPath: [ 'inset(-10% 110% -10% -10%)', 'inset( -10% -10% -10% -10%']\n   },\n\n   textRevealInUp: {\n      \"-webkit-clip-path\": [ 'inset(110% -10% -10% -10%)', 'inset( -10% -10% -10% -10%'],\n      clipPath: [ 'inset(110% -10% -10% -10%)', 'inset( -10% -10% -10% -10%']\n   },\n\n   zoomIn: {\n      opacity: [0, 1],\n      scaleX: [0, 1],\n      scaleY: [0, 1]\n   },\n\n   zoomOut: {\n      opacity: [0, 1],\n      scaleX: [2, 1],\n      scaleY: [2, 1]\n   },\n\n   flipX: {\n      rotateX: [90, 0]\n   },\n\n   flipY: {\n      rotateY: [90, 0]\n   },\n\n   rotateLeft: {\n      opacity: [0, 1],\n      rotate: [360, 0]\n   },\n\n   rotateRight: {\n      opacity: [0, 1],\n      rotate: [-360, 0]\n   },\n\n   standRight: {\n      skewZ: [ 20, 0],\n      rotateX: [90, 0],\n      translateX: [ '-3rem', 0],\n      translateY: [ '3rem', 0]\n   }\n\n   // tilt\n\n\n}\n\nexport default transitions","import anime from 'animejs'\nimport transitions from './transitions'\n\n// Todo: Add 'targets' option to anime to allow array of elements inside parent\n\nclass MotionIO {\n   constructor(el, options) {\n      this.selector = el\n\n      // Callbacks.\n      this.onBegin = function() {}\n      this.onChange = function() {}\n      this.onComplete = function() {}\n      this.onEnter = function() {}\n      this.onLeave = function() {}\n\n      // IntersectionObserver.\n      this.once = false\n      this.threshold = 0.5\n      this.rootMargin = '0px 0px 0px 0px'\n      this.root = null\n      this.hasEntered = false\n\n      // AnimeJS.\n      this.anime = {}\n      this.custom = false\n      this.delay = 0\n      this.duration = 1000\n      this.easing = 'linear'\n      this.children = false\n      this.preset = 'fadeIn'\n      this.stagger = false\n      this.targets = []\n\n      // Override defaults.\n      Object.assign( this, options )\n\n      this.init()\n   }\n\n   init() {\n      this.initAnime()\n      this.initObserver()\n   }\n\n   destroy() {\n      if ( this.observer ) {\n         this.observer.disconnect()\n      }\n   }\n\n   initObserver() {\n      const observerOptions = {\n         threshold: this.threshold,\n         root: this.root,\n         rootMargin: this.rootMargin,\n      }\n\n      const isIntersecting = () => {\n         // Run Animation.\n         if ( this.hasEntered ) {\n            this.anime.pause()\n            this.anime.reverse()\n         }\n         this.anime.play()\n\n         // Run Callback.\n         this.onEnter()\n\n         // Update on first entrance.\n         if ( ! this.hasEntered ) {\n            this.hasEntered = true\n         }\n\n         // Remove observer.\n         if ( this.once ) {\n            this.observer.unobserve(entries[0].target)\n         }\n      }\n\n      const isNotIntersecting = () => {\n         if ( ! this.once && this.hasEntered ) {\n            this.anime.pause()\n            this.anime.reverse()\n            this.anime.play()\n         }\n         this.onLeave()\n      }\n\n      this.observer = new IntersectionObserver((entries) => {\n\n         if (!entries[0].isIntersecting) {\n            isNotIntersecting()\n         } else {\n            isIntersecting()\n         }\n         this.onChange()\n\n      }, observerOptions )\n\n      this.observer.observe(this.selector)\n   }\n\n   initAnime() {\n      const transitionStyle = this.custom ? this.custom : transitions[`${this.preset}`]\n      const staggerOptions = Array.isArray( this.stagger ) ? anime.stagger( ...this.stagger ) : anime.stagger( this.stagger )\n\n      const settings = {\n         targets: this.children ? this.selector.children : this.selector,\n\n         autoplay: false,\n         loop: false,\n\n         ...transitionStyle,\n\n         delay: this.stagger ? staggerOptions : this.delay,\n         duration: this.duration,\n         easing: this.easing,\n\n         begin: this.onBegin,\n         complete: this.onComplete,\n      }\n\n      this.anime = anime({\n         ...settings,\n      })\n   }\n}\n\nexport default MotionIO","import anime from 'animejs'\nimport transitions from './transitions'\n\nclass MotionTextIO {\n   constructor( el, options ) {\n      this.selector = el\n\n      // Text.\n      this.className = 'motionText'\n      this.elementTag = 'span'\n      this.mask = false\n      this.style = true\n      this.text = el.innerText\n      this.textGroup = []\n      this.wordWrap = true\n\n      // Callbacks.\n      this.onBegin = function() {}\n      this.onChange = function() {}\n      this.onComplete = function() {}\n      this.onEnter = function() {}\n      this.onLeave = function() {}\n\n      // IntersectionObserver.\n      this.once = false\n      this.threshold = 0.5\n      this.rootMargin = '0px 0px 0px 0px'\n      this.root = null\n      this.hasEntered = false\n\n      // AnimeJS.\n      this.anime = {}\n      this.custom = false\n      this.delay = 0\n      this.duration = 500\n      this.easing = 'linear'\n      this.preset = 'fadeIn'\n      this.stagger = 100\n\n      // Override defaults.\n      Object.assign( this, options )\n\n      this.init()\n   }\n\n   init() {\n      this.buildText()\n      this.renderText()\n      this.initAnime()\n      this.initObserver()\n   }\n\n   buildText() {\n      const textWord = this.text.split(' ')\n      textWord.map( (word) => {\n         const wordArray = word.split('')\n         this.textGroup = [...this.textGroup, wordArray ]\n      })\n   }\n\n   renderText() {\n      this.selector.innerText = ''\n      if ( this.wordWrap ) {\n         this.buildWrapper()\n      }\n   }\n\n   buildWrapper() {\n      const wrapper = document.createElement(this.elementTag)\n      wrapper.classList.add(this.className)\n      this.selector.appendChild( wrapper )\n      this.buildWords( this.textGroup, wrapper )\n\n   }\n\n   buildWords(phrase, wrapper) {\n      phrase.forEach( (word, index) => {\n         const wordEl = document.createElement( 'span' )\n         wordEl.classList.add( `${this.className}__word` )\n         wordEl.classList.add( `word-${index + 1}` )\n\n         if ( this.style ) {\n            wordEl.style.display = 'inline-flex'\n\n            if ( index > 0 ) {\n               wordEl.style.marginLeft = '0.5rem'\n            }\n         }\n\n         if ( this.mask ) {\n            wordEl.style.webkitClipPath = 'polygon( -10% -10%, 110% -10%, 110% 110%, -10% 110% )'\n            wordEl.style.clipPath = 'polygon( -10% -10%, 110% -10%, 110% 110%, -10% 110% )'\n         }\n\n         wrapper.appendChild( wordEl )\n         this.buildLetters( word, wordEl )\n      })\n   }\n\n   buildLetters( word, wordEl ) {\n      word.forEach( (letter, index) => {\n         const letterEl = document.createElement( 'span' )\n         letterEl.classList.add( `${this.className}__letter` )\n         letterEl.classList.add( `letter-${index + 1}` )\n         letterEl.innerText = letter\n         wordEl.appendChild( letterEl )\n      })\n   }\n\n   destroy() {\n      if ( this.observer ) {\n         this.observer.disconnect()\n      }\n   }\n\n   initObserver() {\n      const observerOptions = {\n         threshold: this.threshold,\n         root: this.root,\n         rootMargin: this.rootMargin,\n      }\n\n      const isIntersecting = ( entries ) => {\n         // Run Animation.\n         if ( this.hasEntered ) {\n            this.anime.pause()\n            this.anime.reverse()\n         }\n         this.anime.play()\n\n         // Run Callback.\n         this.onEnter( entries )\n\n         // Update on first entrance.\n         if ( ! this.hasEntered ) {\n            this.hasEntered = true\n         }\n\n         // Remove observer.\n         if ( this.once ) {\n            this.observer.unobserve(entries[0].target)\n         }\n      }\n\n      const isNotIntersecting = ( entries ) => {\n         if ( ! this.once && this.hasEntered ) {\n            this.anime.pause()\n            this.anime.reverse()\n            this.anime.play()\n         }\n         this.onLeave( entries )\n      }\n\n      this.observer = new IntersectionObserver( (entries) => {\n\n         if (!entries[0].isIntersecting) {\n            isNotIntersecting( entries )\n         } else {\n            isIntersecting( entries )\n         }\n         this.onChange( entries )\n\n      }, observerOptions )\n\n      this.observer.observe(this.selector)\n   }\n\n   initAnime() {\n      const transitionStyle = this.custom || transitions[`${this.preset}`]\n      const staggerOptions = anime.stagger(\n         ...Array.isArray( this.stagger )\n         ? this.stagger\n         : [this.stagger]\n      )\n\n      const settings = {\n         targets: this.selector.querySelectorAll( `.${this.className}__letter` ),\n\n         autoplay: false,\n         loop: false,\n\n         ...transitionStyle,\n\n         delay: this.stagger ? staggerOptions : this.delay,\n         duration: this.duration,\n         easing: this.easing,\n\n         begin: this.onBegin,\n         complete: this.onComplete,\n      }\n\n      this.anime = anime({\n         ...settings,\n      })\n   }\n\n\n}\n\nexport default MotionTextIO","import Vue from 'vue'\nimport anime from 'animejs'\nimport transitions from './transitions'\n\nexport default {\n   name: 'motion',\n\n   props: {\n\n      // IntersectionObserver.\n      once: {\n         type: Boolean,\n         required: false,\n         default: false,\n      },\n      observerRoot: {\n         type: Object,\n         required: false,\n         default: () => ({\n            root: null,\n            rootMargin: '0px',\n         })\n      },\n\n      threshold: {\n         type: [ Function, Array, Number ],\n         required: false,\n         default: 0.5,\n      },\n\n      // AnimeJS.\n      children: {\n         type: [ Array, Boolean ],\n         required: false,\n         default: false,\n      },\n      custom: {\n         type: Object,\n         required: false,\n      },\n      delay: {\n         type: [ Number, Function ],\n         required: false,\n         default: 0,\n      },\n      duration: {\n         type: [ Number, Function ],\n         required: false,\n         default: 1000,\n      },\n      easing: {\n         type: [ String, Function ],\n         required: false,\n         default: 'linear',\n      },\n      origin: {\n         type: String,\n         required: false,\n      },\n      preset: {\n         type: String,\n         required: false,\n         default: 'fadeIn',\n      },\n      svg: {\n         type: Boolean,\n         required: false,\n         default: false,\n      },\n      stagger: {\n         type: [ Array, Number ],\n         required: false,\n      },\n\n   },\n\n   anime: {},\n   observer: {},\n\n   data: () => ({\n      hasEntered: false,\n   }),\n\n   computed: {\n\n      observerOptions() {\n         return {\n            root: this.observerRoot.root,\n            rootMargin: this.observerRoot.rootMargin,\n            threshold: this.threshold\n         }\n      },\n\n      selector() {\n         return this.$el\n      },\n\n      staggerOptions() {\n         return  anime.stagger(\n            ...Array.isArray( this.stagger )\n            ? this.stagger\n            : [this.stagger]\n         )\n      },\n\n      targetSelector() {\n         if ( Array.isArray( this.children ) ) {\n            return this.selector.querySelectorAll( this.children )\n         } else if ( this.children == true ) {\n            return this.selector.children\n         } else {\n            return this.selector\n         }\n      },\n\n      transitionStyle() {\n         return this.custom || transitions[`${this.preset}`]\n      },\n\n      reduceMotion() {\n         return localStorage.getItem('reduceMotion')\n      }\n\n   },\n\n   mounted() {\n      this.initAnime()\n      this.initObserver()\n   },\n\n   beforeDestroy() {\n      if ( this.$options.observer ) {\n         this.$options.observer.disconnect()\n      }\n   },\n\n   render () {\n      return this.$scopedSlots.default()\n      ? this.$scopedSlots.default({ entered: this.hasEntered, anime: this.$options.anime, observer: this.$options.observer })[0]\n      : null\n   },\n\n   methods: {\n\n      // IntersectionObserver.\n      initObserver() {\n         this.$options.observer = new IntersectionObserver( (entries) => {\n\n            if ( !entries[0].isIntersecting ) {\n               this.isNotIntersecting( entries )\n            } else {\n               this.isIntersecting( entries )\n            }\n            this.$emit('change', entries[0].isIntersecting )\n\n         }, this.observerOptions )\n\n         this.$nextTick(() => {\n            this.activateObserver()\n         })\n      },\n\n      activateObserver() {\n         if (this.$scopedSlots.default() && this.$scopedSlots.default().length > 1) {\n\n            this.warn('[MotionIO] You may only wrap one element in a <intersect> component.')\n\n         } else if (!this.$scopedSlots.default() || this.$scopedSlots.default().length < 1) {\n\n            this.warn('[MotionIO] You must have one child inside a <intersect> component.')\n\n            return\n         }\n\n         this.$options.observer.observe( this.selector )\n      },\n\n      isIntersecting( entries ) {\n         // Run Animation.\n         if ( this.hasEntered === true ) {\n            this.$options.anime.pause()\n            this.$options.anime.reverse()\n         }\n         this.$options.anime.play()\n\n         // Run Callback.\n         this.$emit('enter', entries[0])\n\n         // Update on first entrance.\n         if ( ! this.hasEntered ) {\n            this.hasEntered = true\n            return\n         }\n\n         // Remove observer.\n         if ( this.once ) {\n            this.$options.observer.unobserve(entries[0].target)\n         }\n      },\n\n      isNotIntersecting( entries ) {\n         if ( ! this.once && this.hasEntered ) {\n            this.$options.anime.pause()\n            this.$options.anime.reverse()\n            this.$options.anime.play()\n         }\n         this.$emit('leave', entries[0])\n      },\n\n      // AnimeJS.\n      initAnime() {\n         if ( this.origin ) {\n            anime.set( this.targetSelector, { transformOrigin: this.origin })\n         }\n         this.$options.anime = anime({\n            targets: this.targetSelector,\n\n            autoplay: false,\n            loop: false,\n            strokeDashoffset: this.svg ? [anime.setDashoffset, 0] : '',\n\n            ...this.transitionStyle,\n\n            delay: this.stagger ? this.staggerOptions : this.delay,\n            duration: this.reduceMotion == \"true\" ? 0 : this.duration,\n            easing: this.easing,\n\n\n            begin: (...anime) => {\n               this.$emit('begin', anime)\n            },\n            complete: (...anime) => {\n               this.$emit('complete', anime)\n            },\n         })\n      },\n\n      // Utility.\n      warn( message ) {\n         if ( !Vue.config.silent ) {\n            console.error( message )\n         }\n      },\n   },\n\n}\n","import Vue from 'vue'\nimport anime from 'animejs'\nimport transitions from './transitions'\n\nexport default {\n   name: 'motion-text',\n\n   props: {\n      applyStyles: {\n         type: Boolean,\n         required: false,\n         default: true,\n      },\n      block: {\n         type: String,\n         required: false,\n         default: 'motionText',\n      },\n      mask: {\n         type: Boolean,\n         required: false,\n         default: false,\n      },\n      tag: {\n         type: String,\n         required: false,\n         default: 'span',\n      },\n      wordWrap: {\n         type: Boolean,\n         required: false,\n         default: false,\n      },\n\n      // IntersectionObserver.\n      once: {\n         type: Boolean,\n         required: false,\n         default: false,\n      },\n      observerRoot: {\n         type: Object,\n         required: false,\n         default: () => ({\n            root: null,\n            rootMargin: '0px',\n         })\n      },\n\n      threshold: {\n         type: [ Function, Array, Number ],\n         required: false,\n         default: 0.5,\n      },\n\n      // AnimeJS.\n      custom: {\n         type: Object,\n         required: false,\n      },\n      delay: {\n         type: [ Number, Function ],\n         required: false,\n         default: 0,\n      },\n      duration: {\n         type: [ Number, Function ],\n         required: false,\n         default: 500,\n      },\n      easing: {\n         type: [ String, Function ],\n         required: false,\n         default: 'linear',\n      },\n      origin: {\n         type: String,\n         required: false,\n      },\n      preset: {\n         type: String,\n         required: false,\n         default: 'fadeIn',\n      },\n      stagger: {\n         type: [ Array, Number ],\n         required: false,\n         default: 100,\n      },\n   },\n\n   anime: {},\n   observer: {},\n\n   data: () => ({\n      hasEntered: false,\n      html: '',\n   }),\n\n   computed: {\n\n      observerOptions() {\n         return {\n            root: this.observerRoot.root,\n            rootMargin: this.observerRoot.rootMargin,\n            threshold: this.threshold\n         }\n      },\n\n      staggerOptions() {\n         return  anime.stagger(\n            ...Array.isArray( this.stagger )\n            ? this.stagger\n            : [this.stagger]\n         )\n      },\n\n      transitionStyle() {\n         return this.custom || transitions[`${this.preset}`]\n      },\n\n      reduceMotion() {\n         return localStorage.getItem('reduceMotion')\n      }\n   },\n\n   mounted() {\n      this.initAnime()\n      this.initObserver()\n   },\n\n   beforeDestroy() {\n      if ( this.$options.observer ) {\n         this.$options.observer.disconnect()\n      }\n   },\n\n   render: function (h) {\n         return h(\n            this.tag,\n            {\n               class: `${this.block}__wrapper`,\n            },\n            this.$scopedSlots.default({\n               entered: this.hasEntered,\n               anime: this.$options.anime,\n               observer: this.$options.observer\n            }).map( (node) => this.renderBlock(h, node) )\n         )\n   },\n\n   methods: {\n\n      renderBlock(h, block) {\n         // handle tag without text (like a <br/>)\n         /*\n            * If it's something visible, like an <hr/>, you could add in a nested\n            * conditional statement to check for those elements and then return\n            * the block with a `${this.block}__letter` class added so that it can\n            * still be animated. Or a different class/attribute so it can be\n            * animated differently!\n            */\n         if (!block.text && !Array.isArray(block.children)) {\n            return block;\n         }\n\n         // add word span around letters if true.\n         if ( block.text && this.wordWrap ) {\n            return block.text.split(\" \").map( (word, index) => {\n               const wordArray = word.split(\"\").map( (letter) => {\n                  if (letter !== \" \" && letter !== \"\\n\") {\n                     // Return character as span element\n                     return h(\"span\", { class: `${this.block}__letter`, ref: 'letter', refInFor: true, }, letter);\n                  } else {\n                     // Otherwise, return just the space/new line as is, without spans\n                     return letter;\n                  }\n               })\n               return h(\"span\", { class: `${this.block}__word`, style: this.buildStyles(index) }, wordArray )\n            })\n         }\n\n         // Convert each text into <span>\n         if (block.text) {\n            // Convert to array for easier handling\n            return block.text.split(\"\").map( (letter) => {\n               // If it's not a space or newline (could be replaced with regex)\n               if (letter !== \" \" && letter !== \"\\n\") {\n                  // Return character as span element\n                  return h(\"span\", { class: `${this.block}__letter`, ref: 'letter', refInFor: true, }, letter);\n               } else {\n                  // Otherwise, return just the space/new line as is, without spans\n                  return letter;\n               }\n            });\n         }\n\n         // Recursive: if element and has children, loop through each child and re-run\n         if (Array.isArray(block.children)) {\n            return h(\n               block.tag,\n               {\n                  // This captures the class that was added in the slot, if available\n                  // Emptry string if no class\n                  class:\n                     block.data && block.data.staticClass\n                        ? block.data.staticClass\n                        : \"\",\n               },\n               block.children.map((childBlock) => this.renderBlock(h, childBlock))\n            )\n         }\n      },\n\n      buildStyles( index ) {\n         const styles = {}\n\n         if ( this.applyStyles ) {\n            styles.display = 'inline-flex'\n\n            if ( index > 0 ) {\n               styles.marginLeft = '0.5rem'\n            }\n         }\n\n         if ( this.mask ) {\n            styles.webkitClipPath = 'polygon( -10% -10%, 110% -10%, 110% 110%, -10% 110% )'\n            styles.clipPath = 'polygon( -10% -10%, 110% -10%, 110% 110%, -10% 110% )'\n         }\n\n         return styles\n      },\n\n      // IntersectionObserver.\n      initObserver() {\n         this.$options.observer = new IntersectionObserver( (entries) => {\n\n            if ( !entries[0].isIntersecting ) {\n               this.isNotIntersecting( entries )\n            } else {\n               this.isIntersecting( entries )\n            }\n            this.$emit('change', entries[0].isIntersecting )\n\n         }, this.observerOptions )\n\n         this.$nextTick(() => {\n            this.activateObserver()\n         })\n      },\n\n      activateObserver() {\n         this.$options.observer.observe( this.$el )\n      },\n\n      isIntersecting( entries ) {\n         // Run Animation.\n         if ( this.hasEntered ) {\n            this.$options.anime.pause()\n            this.$options.anime.reverse()\n         }\n         setTimeout(() => {\n            this.$options.anime.play()\n         }, this.delay );\n\n         // Run Callback.\n         this.$emit('enter', entries[0])\n\n         // Update on first entrance.\n         if ( ! this.hasEntered ) {\n            this.hasEntered = true\n         }\n\n         // Remove observer.\n         if ( this.once ) {\n            this.$options.observer.unobserve(entries[0].target)\n         }\n      },\n\n      isNotIntersecting( entries ) {\n         if ( ! this.once && this.hasEntered ) {\n            this.$options.anime.pause()\n            this.$options.anime.reverse()\n            this.$options.anime.play()\n         }\n         this.$emit('leave', entries[0])\n      },\n\n      // AnimeJS.\n      initAnime() {\n         if ( this.origin ) {\n            anime.set( this.$refs.letter, { transformOrigin: this.origin })\n         }\n         this.$options.anime = anime({\n            targets: this.$refs.letter,\n\n            autoplay: false,\n            loop: false,\n\n            ...this.transitionStyle,\n\n            delay: this.stagger ? this.staggerOptions : '',\n            duration: this.reduceMotion == \"true\" ? 0 : this.duration,\n            easing: this.easing,\n\n            begin: ( anime ) => {\n               this.$emit('begin', anime)\n            },\n            complete: ( anime ) => {\n               this.$emit('complete', anime)\n            },\n         })\n      },\n\n      warn( message ) {\n         if ( !Vue.config.silent ) {\n            console.error( message )\n         }\n      },\n   }\n}","// Vanilla Components.\nimport MotionIO from '../src/motion-io/motion-io'\nimport MotionTextIO from '../src/motion-io/motion-text-io'\n\n// Vue Components.\nimport Motion from '../src/motion-io/v-motion-io'\nimport MotionText from '../src/motion-io/v-motion-text-io'\n\n// Vue.\nimport Vue from 'vue'\n\n// Reduced Motion.\nimport '../src/motion-io/utilities/reduced-motion'\n\n// eslint-disable-next-line\nnew Vue({\n    el: '#root',\n\n    delimiters: [\"${\", \"}\"],\n\n    components: {\n        Motion,\n        MotionText,\n    },\n\n    mounted() {\n\n        document.querySelectorAll('[data-motion-text]')\n            .forEach( el => new MotionTextIO( el, {\n                preset: 'slideInUp',\n                easing: 'easeOutExpo',\n                mask: false,\n            }))\n\n        document.querySelectorAll('[data-motion]')\n            .forEach( el => new MotionIO( el, {\n                duration: 750,\n                threshold: 0.5,\n                delay: 500,\n                easing: 'easeOutBounce',\n                preset: 'slideInRight',\n        }))\n\n        document.querySelectorAll('[data-motion-group]')\n            .forEach( el => new MotionIO( el, {\n                duration: 1500,\n                threshold: 0.4,\n                easing: 'easeOutCirc',\n                children: true,\n                stagger: 250,\n                preset: 'revealInUp',\n\n        }))\n    },\n})\n","/**\n* Prefers Reduced Motion Settings\n*\n*  Checks for reduced motion setting and stores status in LocalStorage for use in other scripts.\n*\n*/\nconst motionQuery = matchMedia('(prefers-reduced-motion)')\n\n// Store in localStorage for use in other files.\n// Ex.\n// * let reduceMotion = localStorage.getItem('reduceMotion')\n\nconst updateLocalStorage = ( value ) => {\n   localStorage.setItem('reduceMotion', value )\n}\n\nconst stopVideoAutoplay = () => {\n   // Find all HTML5 video elements.\n   const videos = document.querySelectorAll( 'video' )\n   videos.forEach( video => {\n      // Pause all videos with autoplay.\n      const autoplay  = video.getAttribute('autoplay')\n      if ( autoplay ) {\n         video.pause()\n      }\n   })\n}\n\nconst reducedMotionCheck = () => {\n   if ( motionQuery.matches ) {\n      // Add functions for reduced motion here.\n      console.warn('[MOTION-IO]: Reduced Motion setting is active. Autoplay and animations have been turned off.')\n      updateLocalStorage( true )\n      stopVideoAutoplay()\n   } else {\n      updateLocalStorage( false )\n   }\n}\n\nreducedMotionCheck()\nmotionQuery.addEventListener('change', reducedMotionCheck)"],"sourceRoot":""}