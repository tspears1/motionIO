{"version":3,"sources":["webpack://motion-io/./src/motion-io/transitions.js","webpack://motion-io/./src/motion-io/motion-io.js","webpack://motion-io/./src/motion-io/motion-text-io.js","webpack://motion-io/./src/motion-io/v-motion-io.js","webpack://motion-io/./src/motion-io/v-motion-text-io.js","webpack://motion-io/./example/main.js","webpack://motion-io/./src/motion-io/utilities/reduced-motion.js"],"names":["fadeIn","opacity","slideInDown","translateY","slideInLeft","translateX","slideInRight","slideInUp","revealInDown","clipPath","revealInLeft","revealInRight","revealInUp","textRevealInDown","textRevealInLeft","textRevealInRight","textRevealInUp","bounceInDown","easing","bounceInLeft","bounceInRight","bounceInUp","zoomIn","scaleX","scaleY","zoomOut","flipX","rotateX","flipY","rotateY","rotateLeft","rotate","rotateRight","standRight","skewZ","el","options","this","selector","onBegin","onChange","onComplete","onEnter","onLeave","once","threshold","rootMargin","root","hasEntered","anime","custom","delay","duration","children","preset","stagger","targets","Object","assign","init","initAnime","initObserver","observer","disconnect","observerOptions","isIntersecting","pause","reverse","play","unobserve","entries","target","IntersectionObserver","observe","transitionStyle","transitions","staggerOptions","Array","isArray","settings","autoplay","loop","begin","complete","className","elementTag","mask","style","text","innerText","textGroup","wordWrap","buildText","renderText","split","map","word","wordArray","buildWrapper","wrapper","document","createElement","classList","add","appendChild","buildWords","phrase","forEach","index","wordEl","display","marginLeft","webkitClipPath","buildLetters","letter","letterEl","isNotIntersecting","querySelectorAll","name","props","type","Boolean","required","default","observerRoot","Function","Number","String","origin","svg","data","computed","$el","targetSelector","reduceMotion","localStorage","getItem","mounted","beforeDestroy","$options","render","$scopedSlots","entered","methods","$emit","$nextTick","activateObserver","length","warn","transformOrigin","strokeDashoffset","message","Vue","console","error","applyStyles","block","tag","wordTarget","html","animeTarget","$refs","h","class","node","renderBlock","ref","refInFor","buildStyles","staticClass","childBlock","styles","setTimeout","delimiters","components","Motion","MotionText","MotionTextIO","MotionIO","motionQuery","matchMedia","updateLocalStorage","value","setItem","reducedMotionCheck","matches","video","getAttribute","addEventListener"],"mappings":"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","file":"/js/main.js","sourcesContent":["const transitions = {\n\n   fadeIn: {\n      opacity: [0, 1]\n   },\n\n   slideInDown: {\n      opacity: [0, 1],\n      translateY: [ '20vh', 0 ]\n   },\n   slideInLeft: {\n      opacity: [0, 1],\n      translateX: [ '-20vw', 0 ]\n   },\n   slideInRight: {\n      opacity: [0, 1],\n      translateX: [ '20vw', 0 ]\n   },\n   slideInUp: {\n      opacity: [0, 1],\n      translateY: [ '-20vh', 0 ]\n   },\n\n   revealInDown: {\n      \"-webkit-clip-path\": [ 'inset(0% 0% 100% 0%)', 'inset(0% 0% 0% 0%)'],\n      clipPath: [ 'inset(0% 0% 100% 0%)', 'inset(0% 0% 0% 0%)']\n   },\n\n   revealInLeft: {\n      \"-webkit-clip-path\": [ 'inset(0% 0% 0% 100%)', 'inset(0% 0% 0% 0%)'],\n      clipPath: [ 'inset(0% 0% 0% 100%)', 'inset(0% 0% 0% 0%)']\n   },\n\n   revealInRight: {\n      \"-webkit-clip-path\": [ 'inset(0% 100% 0% 0%)', 'inset(0% 0% 0% 0%)'],\n      clipPath: [ 'inset(0% 100% 0% 0%)', 'inset(0% 0% 0% 0%)']\n   },\n\n   revealInUp: {\n      \"-webkit-clip-path\": [ 'inset(100% 0% 0% 0%)', 'inset(0% 0% 0% 0%)'],\n      clipPath: [ 'inset(100% 0% 0% 0%)', 'inset(0% 0% 0% 0%)']\n   },\n\n   textRevealInDown: {\n      \"-webkit-clip-path\": [ 'inset(-10% -10% 110% -10%)', 'inset( -10% -10% -10% -10%'],\n      clipPath: [ 'inset(-10% -10% 110% -10%)', 'inset( -10% -10% -10% -10%']\n   },\n\n   textRevealInLeft: {\n      \"-webkit-clip-path\": [ 'inset(-10% -10% -10% 110%)', 'inset( -10% -10% -10% -10%'],\n      clipPath: [ 'inset(-10% -10% -10% 110%)', 'inset( -10% -10% -10% -10%']\n   },\n\n   textRevealInRight: {\n      \"-webkit-clip-path\": [ 'inset(-10% 110% -10% -10%)', 'inset( -10% -10% -10% -10%'],\n      clipPath: [ 'inset(-10% 110% -10% -10%)', 'inset( -10% -10% -10% -10%']\n   },\n\n   textRevealInUp: {\n      \"-webkit-clip-path\": [ 'inset(110% -10% -10% -10%)', 'inset( -10% -10% -10% -10%'],\n      clipPath: [ 'inset(110% -10% -10% -10%)', 'inset( -10% -10% -10% -10%']\n   },\n\n   bounceInDown: {\n      easing: 'easeOutBounce',\n      opacity: [0, 1],\n      translateY: [ '20vh', 0 ]\n   },\n   bounceInLeft: {\n      easing: 'easeOutBounce',\n      opacity: [0, 1],\n      translateX: [ '-20vw', 0 ]\n   },\n   bounceInRight: {\n      easing: 'easeOutBounce',\n      opacity: [0, 1],\n      translateX: [ '20vw', 0 ]\n   },\n   bounceInUp: {\n      easing: 'easeOutBounce',\n      opacity: [0, 1],\n      translateY: [ '-20vh', 0 ]\n   },\n\n   zoomIn: {\n      opacity: [0, 1],\n      scaleX: [0, 1],\n      scaleY: [0, 1]\n   },\n\n   zoomOut: {\n      opacity: [0, 1],\n      scaleX: [2, 1],\n      scaleY: [2, 1]\n   },\n\n   flipX: {\n      rotateX: [90, 0]\n   },\n\n   flipY: {\n      rotateY: [90, 0]\n   },\n\n   rotateLeft: {\n      opacity: [0, 1],\n      rotate: [360, 0]\n   },\n\n   rotateRight: {\n      opacity: [0, 1],\n      rotate: [-360, 0]\n   },\n\n   standRight: {\n      skewZ: [ 20, 0],\n      rotateX: [90, 0],\n      translateX: [ '-3rem', 0],\n      translateY: [ '3rem', 0]\n   }\n\n   // tilt\n\n\n}\n\nexport default transitions","import anime from 'animejs'\nimport transitions from './transitions'\n\n// Todo: Add 'targets' option to anime to allow array of elements inside parent\n\nclass MotionIO {\n   constructor(el, options) {\n      this.selector = el\n\n      // Callbacks.\n      this.onBegin = function() {}\n      this.onChange = function() {}\n      this.onComplete = function() {}\n      this.onEnter = function() {}\n      this.onLeave = function() {}\n\n      // IntersectionObserver.\n      this.once = false\n      this.threshold = 0.5\n      this.rootMargin = '0px 0px 0px 0px'\n      this.root = null\n      this.hasEntered = false\n\n      // AnimeJS.\n      this.anime = {}\n      this.custom = false\n      this.delay = 0\n      this.duration = 1000\n      this.easing = 'linear'\n      this.children = false\n      this.preset = 'fadeIn'\n      this.stagger = false\n      this.targets = []\n\n      // Override defaults.\n      Object.assign( this, options )\n\n      this.init()\n   }\n\n   init() {\n      this.initAnime()\n      this.initObserver()\n   }\n\n   destroy() {\n      if ( this.observer ) {\n         this.observer.disconnect()\n      }\n   }\n\n   initObserver() {\n      const observerOptions = {\n         threshold: this.threshold,\n         root: this.root,\n         rootMargin: this.rootMargin,\n      }\n\n      const isIntersecting = () => {\n         // Run Animation.\n         if ( this.hasEntered ) {\n            this.anime.pause()\n            this.anime.reverse()\n         }\n         this.anime.play()\n\n         // Run Callback.\n         this.onEnter()\n\n         // Update on first entrance.\n         if ( ! this.hasEntered ) {\n            this.hasEntered = true\n         }\n\n         // Remove observer.\n         if ( this.once ) {\n            this.observer.unobserve(entries[0].target)\n         }\n      }\n\n      const isNotIntersecting = () => {\n         if ( ! this.once && this.hasEntered ) {\n            this.anime.pause()\n            this.anime.reverse()\n            this.anime.play()\n         }\n         this.onLeave()\n      }\n\n      this.observer = new IntersectionObserver((entries) => {\n\n         if (!entries[0].isIntersecting) {\n            isNotIntersecting()\n         } else {\n            isIntersecting()\n         }\n         this.onChange()\n\n      }, observerOptions )\n\n      this.observer.observe(this.selector)\n   }\n\n   initAnime() {\n      const transitionStyle = this.custom ? this.custom : transitions[`${this.preset}`]\n      const staggerOptions = Array.isArray( this.stagger ) ? anime.stagger( ...this.stagger ) : anime.stagger( this.stagger )\n\n      const settings = {\n         targets: this.children ? this.selector.children : this.selector,\n\n         autoplay: false,\n         loop: false,\n\n         ...transitionStyle,\n\n         delay: this.stagger ? staggerOptions : this.delay,\n         duration: this.duration,\n         easing: this.easing,\n\n         begin: this.onBegin,\n         complete: this.onComplete,\n      }\n\n      this.anime = anime({\n         ...settings,\n      })\n   }\n}\n\nexport default MotionIO","import anime from 'animejs'\nimport transitions from './transitions'\n\nclass MotionTextIO {\n   constructor( el, options ) {\n      this.selector = el\n\n      // Text.\n      this.className = 'motionText'\n      this.elementTag = 'span'\n      this.mask = false\n      this.style = true\n      this.text = el.innerText\n      this.textGroup = []\n      this.wordWrap = true\n\n      // Callbacks.\n      this.onBegin = function() {}\n      this.onChange = function() {}\n      this.onComplete = function() {}\n      this.onEnter = function() {}\n      this.onLeave = function() {}\n\n      // IntersectionObserver.\n      this.once = false\n      this.threshold = 0.5\n      this.rootMargin = '0px 0px 0px 0px'\n      this.root = null\n      this.hasEntered = false\n\n      // AnimeJS.\n      this.anime = {}\n      this.custom = false\n      this.delay = 0\n      this.duration = 500\n      this.easing = 'linear'\n      this.preset = 'fadeIn'\n      this.stagger = 100\n\n      // Override defaults.\n      Object.assign( this, options )\n\n      this.init()\n   }\n\n   init() {\n      this.buildText()\n      this.renderText()\n      this.initAnime()\n      this.initObserver()\n   }\n\n   buildText() {\n      const textWord = this.text.split(' ')\n      textWord.map( (word) => {\n         const wordArray = word.split('')\n         this.textGroup = [...this.textGroup, wordArray ]\n      })\n   }\n\n   renderText() {\n      this.selector.innerText = ''\n      if ( this.wordWrap ) {\n         this.buildWrapper()\n      }\n   }\n\n   buildWrapper() {\n      const wrapper = document.createElement(this.elementTag)\n      wrapper.classList.add(this.className)\n      this.selector.appendChild( wrapper )\n      this.buildWords( this.textGroup, wrapper )\n\n   }\n\n   buildWords(phrase, wrapper) {\n      phrase.forEach( (word, index) => {\n         const wordEl = document.createElement( 'span' )\n         wordEl.classList.add( `${this.className}__word` )\n         wordEl.classList.add( `word-${index + 1}` )\n\n         if ( this.style ) {\n            wordEl.style.display = 'inline-flex'\n\n            if ( index > 0 ) {\n               wordEl.style.marginLeft = '0.5rem'\n            }\n         }\n\n         if ( this.mask ) {\n            wordEl.style.webkitClipPath = 'polygon( -10% -10%, 110% -10%, 110% 110%, -10% 110% )'\n            wordEl.style.clipPath = 'polygon( -10% -10%, 110% -10%, 110% 110%, -10% 110% )'\n         }\n\n         wrapper.appendChild( wordEl )\n         this.buildLetters( word, wordEl )\n      })\n   }\n\n   buildLetters( word, wordEl ) {\n      word.forEach( (letter, index) => {\n         const letterEl = document.createElement( 'span' )\n         letterEl.classList.add( `${this.className}__letter` )\n         letterEl.classList.add( `letter-${index + 1}` )\n         letterEl.innerText = letter\n         wordEl.appendChild( letterEl )\n      })\n   }\n\n   destroy() {\n      if ( this.observer ) {\n         this.observer.disconnect()\n      }\n   }\n\n   initObserver() {\n      const observerOptions = {\n         threshold: this.threshold,\n         root: this.root,\n         rootMargin: this.rootMargin,\n      }\n\n      const isIntersecting = ( entries ) => {\n         // Run Animation.\n         if ( this.hasEntered ) {\n            this.anime.pause()\n            this.anime.reverse()\n         }\n         this.anime.play()\n\n         // Run Callback.\n         this.onEnter( entries )\n\n         // Update on first entrance.\n         if ( ! this.hasEntered ) {\n            this.hasEntered = true\n         }\n\n         // Remove observer.\n         if ( this.once ) {\n            this.observer.unobserve(entries[0].target)\n         }\n      }\n\n      const isNotIntersecting = ( entries ) => {\n         if ( ! this.once && this.hasEntered ) {\n            this.anime.pause()\n            this.anime.reverse()\n            this.anime.play()\n         }\n         this.onLeave( entries )\n      }\n\n      this.observer = new IntersectionObserver( (entries) => {\n\n         if (!entries[0].isIntersecting) {\n            isNotIntersecting( entries )\n         } else {\n            isIntersecting( entries )\n         }\n         this.onChange( entries )\n\n      }, observerOptions )\n\n      this.observer.observe(this.selector)\n   }\n\n   initAnime() {\n      const transitionStyle = this.custom || transitions[`${this.preset}`]\n      const staggerOptions = anime.stagger(\n         ...Array.isArray( this.stagger )\n         ? this.stagger\n         : [this.stagger]\n      )\n\n      const settings = {\n         targets: this.selector.querySelectorAll( `.${this.className}__letter` ),\n\n         autoplay: false,\n         loop: false,\n\n         ...transitionStyle,\n\n         delay: this.stagger ? staggerOptions : this.delay,\n         duration: this.duration,\n         easing: this.easing,\n\n         begin: this.onBegin,\n         complete: this.onComplete,\n      }\n\n      this.anime = anime({\n         ...settings,\n      })\n   }\n\n\n}\n\nexport default MotionTextIO","import Vue from 'vue'\nimport anime from 'animejs'\nimport transitions from './transitions'\n\nexport default {\n   name: 'motion',\n\n   props: {\n\n      // IntersectionObserver.\n      once: {\n         type: Boolean,\n         required: false,\n         default: false,\n      },\n      observerRoot: {\n         type: Object,\n         required: false,\n         default: () => ({\n            root: null,\n            rootMargin: '0px',\n         })\n      },\n\n      threshold: {\n         type: [ Function, Array, Number ],\n         required: false,\n         default: 0.5,\n      },\n\n      // AnimeJS.\n      children: {\n         type: [ Array, Boolean ],\n         required: false,\n         default: false,\n      },\n      custom: {\n         type: Object,\n         required: false,\n      },\n      delay: {\n         type: [ Number, Function ],\n         required: false,\n         default: 0,\n      },\n      duration: {\n         type: [ Number, Function ],\n         required: false,\n         default: 1000,\n      },\n      easing: {\n         type: [ String, Function ],\n         required: false,\n         default: 'linear',\n      },\n      origin: {\n         type: String,\n         required: false,\n      },\n      preset: {\n         type: String,\n         required: false,\n         default: 'fadeIn',\n      },\n      svg: {\n         type: Boolean,\n         required: false,\n         default: false,\n      },\n      stagger: {\n         type: [ Array, Number ],\n         required: false,\n      },\n\n   },\n\n   anime: {},\n   observer: {},\n\n   data: () => ({\n      hasEntered: false,\n   }),\n\n   computed: {\n\n      observerOptions() {\n         return {\n            root: this.observerRoot.root,\n            rootMargin: this.observerRoot.rootMargin,\n            threshold: this.threshold\n         }\n      },\n\n      selector() {\n         return this.$el\n      },\n\n      staggerOptions() {\n         return  anime.stagger(\n            ...Array.isArray( this.stagger )\n            ? this.stagger\n            : [this.stagger]\n         )\n      },\n\n      targetSelector() {\n         if ( Array.isArray( this.children ) ) {\n            return this.selector.querySelectorAll( this.children )\n         } else if ( this.children == true ) {\n            return this.selector.children\n         } else {\n            return this.selector\n         }\n      },\n\n      transitionStyle() {\n         return this.custom || transitions[`${this.preset}`]\n      },\n\n      reduceMotion() {\n         return localStorage.getItem('reduceMotion')\n      }\n\n   },\n\n   mounted() {\n      this.initAnime()\n      this.initObserver()\n   },\n\n   beforeDestroy() {\n      if ( this.$options.observer ) {\n         this.$options.observer.disconnect()\n      }\n   },\n\n   render () {\n      return this.$scopedSlots.default()\n      ? this.$scopedSlots.default({ entered: this.hasEntered, anime: this.$options.anime, observer: this.$options.observer })[0]\n      : null\n   },\n\n   methods: {\n\n      // IntersectionObserver.\n      initObserver() {\n         this.$options.observer = new IntersectionObserver( (entries) => {\n\n            if ( !entries[0].isIntersecting ) {\n               this.isNotIntersecting( entries )\n            } else {\n               this.isIntersecting( entries )\n            }\n            this.$emit('change', entries[0].isIntersecting )\n\n         }, this.observerOptions )\n\n         this.$nextTick(() => {\n            this.activateObserver()\n         })\n      },\n\n      activateObserver() {\n         if (this.$scopedSlots.default() && this.$scopedSlots.default().length > 1) {\n\n            this.warn('[MotionIO] You may only wrap one element in a <intersect> component.')\n\n         } else if (!this.$scopedSlots.default() || this.$scopedSlots.default().length < 1) {\n\n            this.warn('[MotionIO] You must have one child inside a <intersect> component.')\n\n            return\n         }\n\n         this.$options.observer.observe( this.selector )\n      },\n\n      isIntersecting( entries ) {\n         // Run Animation.\n         if ( this.hasEntered === true ) {\n            this.$options.anime.pause()\n            this.$options.anime.reverse()\n         }\n         this.$options.anime.play()\n\n         // Run Callback.\n         this.$emit('enter', entries[0])\n\n         // Update on first entrance.\n         if ( ! this.hasEntered ) {\n            this.hasEntered = true\n            return\n         }\n\n         // Remove observer.\n         if ( this.once ) {\n            this.$options.observer.unobserve(entries[0].target)\n         }\n      },\n\n      isNotIntersecting( entries ) {\n         if ( ! this.once && this.hasEntered ) {\n            this.$options.anime.pause()\n            this.$options.anime.reverse()\n            this.$options.anime.play()\n         }\n         this.$emit('leave', entries[0])\n      },\n\n      // AnimeJS.\n      initAnime() {\n         if ( this.origin ) {\n            anime.set( this.targetSelector, { transformOrigin: this.origin })\n         }\n         this.$options.anime = anime({\n            targets: this.targetSelector,\n\n            autoplay: false,\n            loop: false,\n            strokeDashoffset: this.svg ? [anime.setDashoffset, 0] : '',\n\n            ...this.transitionStyle,\n\n            delay: this.stagger ? this.staggerOptions : this.delay,\n            duration: this.reduceMotion == \"true\" ? 0 : this.duration,\n            easing: this.easing,\n\n\n            begin: (...anime) => {\n               this.$emit('begin', anime)\n            },\n            complete: (...anime) => {\n               this.$emit('complete', anime)\n            },\n         })\n      },\n\n      // Utility.\n      warn( message ) {\n         if ( !Vue.config.silent ) {\n            console.error( message )\n         }\n      },\n   },\n\n}\n","import Vue from 'vue'\nimport anime from 'animejs'\nimport transitions from './transitions'\n\nexport default {\n   name: 'motion-text',\n\n   props: {\n      applyStyles: {\n         type: Boolean,\n         required: false,\n         default: true,\n      },\n      block: {\n         type: String,\n         required: false,\n         default: 'motionText',\n      },\n      mask: {\n         type: Boolean,\n         required: false,\n         default: false,\n      },\n      tag: {\n         type: String,\n         required: false,\n         default: 'span',\n      },\n      wordTarget: {\n         type: Boolean,\n         required: false,\n         default: false,\n      },\n      wordWrap: {\n         type: Boolean,\n         required: false,\n         default: true,\n      },\n\n      // IntersectionObserver.\n      once: {\n         type: Boolean,\n         required: false,\n         default: false,\n      },\n      observerRoot: {\n         type: Object,\n         required: false,\n         default: () => ({\n            root: null,\n            rootMargin: '0px',\n         })\n      },\n\n      threshold: {\n         type: [ Function, Array, Number ],\n         required: false,\n         default: 0.5,\n      },\n\n      // AnimeJS.\n      custom: {\n         type: Object,\n         required: false,\n      },\n      delay: {\n         type: [ Number, Function ],\n         required: false,\n         default: 0,\n      },\n      duration: {\n         type: [ Number, Function ],\n         required: false,\n         default: 500,\n      },\n      easing: {\n         type: [ String, Function ],\n         required: false,\n         default: 'linear',\n      },\n      origin: {\n         type: String,\n         required: false,\n      },\n      preset: {\n         type: String,\n         required: false,\n         default: 'fadeIn',\n      },\n      stagger: {\n         type: [ Array, Number ],\n         required: false,\n         default: 100,\n      },\n   },\n\n   anime: {},\n   observer: {},\n\n   data: () => ({\n      hasEntered: false,\n      html: '',\n   }),\n\n   computed: {\n\n      animeTarget() {\n         return this.wordTarget ? this.$refs.word : this.$refs.letter\n      },\n\n      observerOptions() {\n         return {\n            root: this.observerRoot.root,\n            rootMargin: this.observerRoot.rootMargin,\n            threshold: this.threshold\n         }\n      },\n\n      staggerOptions() {\n         return  anime.stagger(\n            ...Array.isArray( this.stagger )\n            ? this.stagger\n            : [this.stagger]\n         )\n      },\n\n      transitionStyle() {\n         return this.custom || transitions[`${this.preset}`]\n      },\n\n      reduceMotion() {\n         return localStorage.getItem('reduceMotion')\n      }\n   },\n\n   mounted() {\n      this.initAnime()\n      this.initObserver()\n   },\n\n   beforeDestroy() {\n      if ( this.$options.observer ) {\n         this.$options.observer.disconnect()\n      }\n   },\n\n   render: function (h) {\n         return h(\n            this.tag,\n            {\n               class: `${this.block}__wrapper`,\n            },\n            this.$scopedSlots.default({\n               entered: this.hasEntered,\n               anime: this.$options.anime,\n               observer: this.$options.observer\n            }).map( (node) => this.renderBlock(h, node) )\n         )\n   },\n\n   methods: {\n\n      renderBlock(h, block) {\n         // handle tag without text (like a <br/>)\n         /*\n            * If it's something visible, like an <hr/>, you could add in a nested\n            * conditional statement to check for those elements and then return\n            * the block with a `${this.block}__letter` class added so that it can\n            * still be animated. Or a different class/attribute so it can be\n            * animated differently!\n            */\n         if (!block.text && !Array.isArray(block.children)) {\n            return block;\n         }\n\n         // add word span around letters if true.\n         if ( block.text && this.wordWrap ) {\n            return block.text.split(\" \").map( (word, index) => {\n               const wordArray = word.split(\"\").map( (letter) => {\n                  if (letter !== \" \" && letter !== \"\\n\") {\n                     // Return character as span element\n                     return h(\"span\", { class: `${this.block}__letter`, ref: 'letter', refInFor: true, }, letter);\n                  } else {\n                     // Otherwise, return just the space/new line as is, without spans\n                     return letter;\n                  }\n               })\n               return h(\"span\", { class: `${this.block}__word`, ref: 'word', refInFor: true, style: this.buildStyles(index) }, wordArray )\n            })\n         }\n\n         // Convert each text into <span>\n         if (block.text) {\n            // Convert to array for easier handling\n            return block.text.split(\"\").map( (letter) => {\n               // If it's not a space or newline (could be replaced with regex)\n               if (letter !== \" \" && letter !== \"\\n\") {\n                  // Return character as span element\n                  return h(\"span\", { class: `${this.block}__letter`, ref: 'letter', refInFor: true, }, letter);\n               } else {\n                  // Otherwise, return just the space/new line as is, without spans\n                  return letter;\n               }\n            });\n         }\n\n         // Recursive: if element and has children, loop through each child and re-run\n         if (Array.isArray(block.children)) {\n            return h(\n               block.tag,\n               {\n                  // This captures the class that was added in the slot, if available\n                  // Emptry string if no class\n                  class:\n                     block.data && block.data.staticClass\n                        ? block.data.staticClass\n                        : \"\",\n               },\n               block.children.map((childBlock) => this.renderBlock(h, childBlock))\n            )\n         }\n      },\n\n      buildStyles( index ) {\n         const styles = {}\n\n         if ( this.applyStyles ) {\n            styles.display = 'inline-flex'\n\n            if ( index > 0 ) {\n               styles.marginLeft = '0.8rem'\n            }\n         }\n\n         if ( this.mask ) {\n            styles.webkitClipPath = 'polygon( -10% -10%, 110% -10%, 110% 110%, -10% 110% )'\n            styles.clipPath = 'polygon( -10% -10%, 110% -10%, 110% 110%, -10% 110% )'\n         }\n\n         return styles\n      },\n\n      // IntersectionObserver.\n      initObserver() {\n         this.$options.observer = new IntersectionObserver( (entries) => {\n\n            if ( !entries[0].isIntersecting ) {\n               this.isNotIntersecting( entries )\n            } else {\n               this.isIntersecting( entries )\n            }\n            this.$emit('change', entries[0].isIntersecting )\n\n         }, this.observerOptions )\n\n         this.$nextTick(() => {\n            this.activateObserver()\n         })\n      },\n\n      activateObserver() {\n         this.$options.observer.observe( this.$el )\n      },\n\n      isIntersecting( entries ) {\n         // Run Animation.\n         if ( this.hasEntered ) {\n            this.$options.anime.pause()\n            this.$options.anime.reverse()\n         }\n         setTimeout(() => {\n            this.$options.anime.play()\n         }, this.delay );\n\n         // Run Callback.\n         this.$emit('enter', entries[0])\n\n         // Update on first entrance.\n         if ( ! this.hasEntered ) {\n            this.hasEntered = true\n         }\n\n         // Remove observer.\n         if ( this.once ) {\n            this.$options.observer.unobserve(entries[0].target)\n         }\n      },\n\n      isNotIntersecting( entries ) {\n         if ( ! this.once && this.hasEntered ) {\n            this.$options.anime.pause()\n            this.$options.anime.reverse()\n            this.$options.anime.play()\n         }\n         this.$emit('leave', entries[0])\n      },\n\n      // AnimeJS.\n      initAnime() {\n         if ( this.origin ) {\n            anime.set( this.animeTarget, { transformOrigin: this.origin })\n         }\n         this.$options.anime = anime({\n            targets: this.animeTarget,\n\n            autoplay: false,\n            loop: false,\n\n            ...this.transitionStyle,\n\n            delay: this.stagger ? this.staggerOptions : '',\n            duration: this.reduceMotion == \"true\" ? 0 : this.duration,\n            easing: this.easing,\n\n            begin: ( anime ) => {\n               this.$emit('begin', anime)\n            },\n            complete: ( anime ) => {\n               this.$emit('complete', anime)\n            },\n         })\n      },\n\n      warn( message ) {\n         if ( !Vue.config.silent ) {\n            console.error( message )\n         }\n      },\n   }\n}","// Vanilla Components.\nimport MotionIO from '../src/motion-io/motion-io'\nimport MotionTextIO from '../src/motion-io/motion-text-io'\n\n// Vue Components.\nimport Motion from '../src/motion-io/v-motion-io'\nimport MotionText from '../src/motion-io/v-motion-text-io'\n\n// Vue.\nimport Vue from 'vue'\n\n// Reduced Motion.\nimport '../src/motion-io/utilities/reduced-motion'\n\n// eslint-disable-next-line\nnew Vue({\n    el: '#root',\n\n    delimiters: [\"${\", \"}\"],\n\n    components: {\n        Motion,\n        MotionText,\n    },\n\n    mounted() {\n\n        document.querySelectorAll('[data-motion-text]')\n            .forEach( el => new MotionTextIO( el, {\n                preset: 'slideInUp',\n                easing: 'easeOutExpo',\n                mask: false,\n            }))\n\n        document.querySelectorAll('[data-motion]')\n            .forEach( el => new MotionIO( el, {\n                duration: 750,\n                threshold: 0.5,\n                delay: 500,\n                easing: 'easeOutBounce',\n                preset: 'slideInRight',\n        }))\n\n        document.querySelectorAll('[data-motion-group]')\n            .forEach( el => new MotionIO( el, {\n                duration: 1500,\n                threshold: 0.4,\n                easing: 'easeOutCirc',\n                children: true,\n                stagger: 250,\n                preset: 'revealInUp',\n\n        }))\n    },\n})\n","/**\n* Prefers Reduced Motion Settings\n*\n*  Checks for reduced motion setting and stores status in LocalStorage for use in other scripts.\n*\n*/\nconst motionQuery = matchMedia('(prefers-reduced-motion)')\n\n// Store in localStorage for use in other files.\n// Ex.\n// * let reduceMotion = localStorage.getItem('reduceMotion')\n\nconst updateLocalStorage = ( value ) => {\n   localStorage.setItem('reduceMotion', value )\n}\n\nconst stopVideoAutoplay = () => {\n   // Find all HTML5 video elements.\n   const videos = document.querySelectorAll( 'video' )\n   videos.forEach( video => {\n      // Pause all videos with autoplay.\n      const autoplay  = video.getAttribute('autoplay')\n      if ( autoplay ) {\n         video.pause()\n      }\n   })\n}\n\nconst reducedMotionCheck = () => {\n   if ( motionQuery.matches ) {\n      // Add functions for reduced motion here.\n      console.warn('[MOTION-IO]: Reduced Motion setting is active. Autoplay and animations have been turned off.')\n      updateLocalStorage( true )\n      stopVideoAutoplay()\n   } else {\n      updateLocalStorage( false )\n   }\n}\n\nreducedMotionCheck()\nmotionQuery.addEventListener('change', reducedMotionCheck)"],"sourceRoot":""}